#!/bin/bash
#别问我为啥又写这脑抽玩意，去问我40分的英语卷子吧   项目创建于2025年10月25日                                               我要洋人死！！！
#Ubuntu Command Simplification Tool——————Ubuntu命令简化工具     退一万步讲，日常英语这个吧还算挺不错，嗯，是的，大醉作此篇      hxlg
CALLED_NAME=$(basename "$0") #获取调用
if [ "$CALLED_NAME" = "UCST-English" ]; then # 如果直接通过该命令包调用，使用第一个参数作为命令
    CMD="$1"
    shift #shit
else
    CMD="$CALLED_NAME" #如果通过符号链接调用，使用链接名作为命令
fi
ARGS="$@" #原有的命令函数定义保持不变
silent_link_verify() {
    local today=$(date +%Y%m%d) #每天第一次运行时检查
    local last_check_file="/tmp/.command_links_last_check"
    if [ -f "$last_check_file" ] && [ "$(cat "$last_check_file")" = "$today" ]; then #每天第一次运行时检查
        return 0
    fi
    local commands=("about" "list" "network" "disk" "ctime" "process" "helpUCST" "nkill" "open" "delete" "new" "mod" "driver" "backup" "check" "UCST") #验证命令列表
    local main_command="/usr/local/bin/UCST-English"
    if [ ! -f "$main_command" ]; then #检查主命令文件
        return 1
    fi
    local current_perm=$(stat -c "%a" "$main_command" 2>/dev/null) #检查文件权限
    local expected_perm="755"
    if [ "$current_perm" != "$expected_perm" ]; then #若权限有问题，修复文件权限
        sudo chmod "$expected_perm" "$main_command" >/dev/null 2>&1
    fi
    for cmd in "${commands[@]}"; do #检查并修复所有命令链接的权限
        local link_path="/usr/local/bin/$cmd"
        if [ ! -L "$link_path" ] || [ "$(readlink "$link_path")" != "$main_command" ]; then #检查链接是否存在且正确
            sudo ln -sf "$main_command" "$link_path" >/dev/null 2>&1 #静默修复链接（不输出任何信息）
        fi
        if [ -L "$link_path" ]; then #修复链接文件的权限（如果需要，得看前段代码的判断结果）
            local link_perm=$(stat -c "%a" "$link_path" 2>/dev/null)
            if [ "$link_perm" != "$expected_perm" ]; then
                sudo chmod "$expected_perm" "$link_path" >/dev/null 2>&1
            fi
        fi
    done
    echo "$today" > "$last_check_file" #记录今天检查
    return 0
}
silent_link_verify >/dev/null 2>&1 & #静默运行链接验证（始终且持续静默）
command_about() {
    case "$ARGS" in
        "-a")
            echo "=== 详细信息 ==="
            echo "主机名: $(hostname)"
            echo "操作系统: $(lsb_release -ds 2>/dev/null || echo 'Ubuntu 24.04')"
            echo "内核版本: $(uname -r)"
            echo "系统架构: $(uname -m)"
            echo "处理器: $(lscpu | grep "Model name" | cut -d: -f2 | sed 's/^ *//' || echo 'N/A')"
            echo "处理器核心数: $(nproc)"
            echo "系统运行时间: $(uptime -p | sed 's/up //')"
            echo "最后启动时间: $(who -b | awk '{print $3 " " $4}')"
            echo "当前用户: $(whoami)"
            echo "用户权限: $(id -un) ($(id -u))"
            echo "内存总量: $(free -h | awk 'NR==2{print $2}')"
            echo "已用内存: $(free -h | awk 'NR==2{print $3}')"
            echo "可用内存: $(free -h | awk 'NR==2{print $7}')"
            echo "内存使用率: $(free | awk 'NR==2{printf "%.1f%%", $3/$2*100}')"
            echo "交换空间: $(free -h | awk 'NR==3{print $2}')"
            echo "磁盘总量: $(df -h / | awk 'NR==2{print $2}')"
            echo "已用磁盘: $(df -h / | awk 'NR==2{print $3}')"
            echo "可用磁盘: $(df -h / | awk 'NR==2{print $4}')"
            echo "磁盘使用率: $(df -h / | awk 'NR==2{print $5}')"
            echo "IP地址: $(hostname -I)"
            echo "MAC地址: $(ip link show | grep -E '^[0-9]+:' | grep -v lo | head -1 | awk '{print $2}')"
            echo "时区: $(timedatectl show --value -p Timezone 2>/dev/null || echo 'UTC')"
            echo "区域设置: $(locale | grep LANG= | cut -d= -f2)"
            if grep -q microsoft /proc/version 2>/dev/null; then
                echo "环境: WSL (Windows Subsystem for Linux)"
                echo "Windows 主机名: $(grep nameserver /etc/resolv.conf | awk '{print $2}')"
                echo "WSL 版本: $(uname -r | grep -o 'WSL2' || echo 'WSL1')"
            else
                echo "环境: 原生 Linux"
            fi
            ;;
        "-c")
            echo "=== 处理器信息 ==="
            if command -v lscpu >/dev/null 2>&1; then
                echo "品牌: $(lscpu | grep "Vendor ID" | cut -d: -f2 | sed 's/^ *//')"
                echo "型号: $(lscpu | grep "Model name" | cut -d: -f2 | sed 's/^ *//')"
                echo "架构: $(lscpu | grep "Architecture" | cut -d: -f2 | sed 's/^ *//')"
                echo "核心数: $(nproc)"
                echo "状态: 驱动已安装，设备正在正常运行"
            else
                echo "状态: 无法获取处理器信息，请检查处理器是否正常工作或安装lscpu工具以获取信息"
            fi
            ;;
        "-g")
            echo "=== 显卡信息 ==="
            local gpu_detected=false #尝试多种方法获取多种显卡的信息
            if command -v lspci >/dev/null 2>&1; then #使用lspci显卡并提取型号
                local gpu_info=$(lspci | grep -iE "vga|3d|display" | head -1)
                if [ -n "$gpu_info" ]; then
                    local gpu_model=$(echo "$gpu_info" | sed 's/.*: //') #从lspci提取显卡型号
                    echo "设备: $gpu_model"
                    gpu_detected=true
                    if echo "$gpu_model" | grep -i "nvidia" >/dev/null; then #根据关键词判断品牌
                        echo "显卡品牌: NVIDIA"
                    elif echo "$gpu_model" | grep -i "amd" >/dev/null || echo "$gpu_model" | grep -i "ati" >/dev/null; then
                        echo "显卡品牌: AMD"
                    elif echo "$gpu_model" | grep -i "intel" >/dev/null; then
                        echo "显卡品牌: Intel"
                    else
                        local brand=$(echo "$gpu_info" | grep -o -iE "nvidia|amd|ati|intel" | head -1) #从设备描述中提取品牌信息
                        if [ -n "$brand" ]; then
                            echo "显卡品牌: $(echo "$brand" | tr '[:lower:]' '[:upper:]')"
                        fi
                    fi
                fi
            fi
            if command -v nvidia-smi >/dev/null 2>&1; then #检查英伟达显卡驱动状态
                local nvidia_info=$(nvidia-smi --query-gpu=name --format=csv,noheader 2>/dev/null | head -1)
                if [ -n "$nvidia_info" ]; then
                    echo "型号: $nvidia_info"
                    echo "状态: 驱动已安装，设备正在正常运行"
                    gpu_detected=true
                fi
            else
                if lspci | grep -i nvidia >/dev/null 2>&1; then #检查是否存在英伟达显卡但无状态
                    echo "品牌: NVIDIA"
                    echo "状态: 检测到有英伟达显卡存在，但无法获取设备状态，请检查驱动是否正确"
                    gpu_detected=true
                fi
            fi
            
            
            if command -v lshw >/dev/null 2>&1; then #使用lshw获取更详细的显卡信息（如果可用）
                local lshw_gpu=$(lshw -C display 2>/dev/null | head -10)
                if [ -n "$lshw_gpu" ] && [ "$gpu_detected" = false ]; then
                    echo "检测到的显卡:"
                    echo "$lshw_gpu" | grep -E "(product|vendor|description):" | head -5
                    gpu_detected=true
                fi
            fi
            if [ -d "/sys/class/drm" ] && [ "$gpu_detected" = false ]; then #检查/sys/class/drm目录
                local drm_cards=$(find /sys/class/drm -name "card*" -type l | grep -v "control" | sort)
                for card in $drm_cards; do
                    if [ -f "$card/device/uevent" ]; then
                        local drm_vendor=$(grep "DRIVER" "$card/device/uevent" | head -1 | cut -d= -f2)
                        local drm_product=$(grep "MODALIAS" "$card/device/uevent" | head -1 | cut -d= -f2)
                        if [ -n "$drm_vendor" ]; then
                            echo "DRM设备: $drm_vendor"
                            if [ -n "$drm_product" ]; then
                                echo "型号标识: $drm_product"
                            fi
                            gpu_detected=true
                            break
                        fi
                    fi
                done
            fi
            if [ "$gpu_detected" = false ]; then #如果未检测到任何显卡设备
                echo "状态: 未检测到显卡设备，请检查设备和驱动是否正常工作"
            else
                # 如果已经检测到 GPU 但没有显示具体状态，显示默认状态
                if ! echo "$(about -g)" | grep -q "状态:"; then
                    echo "状态: 设备已识别，但未能检测到设备状态"
                fi
            fi
            ;;
        "-o")
            echo "=== 操作系统信息 ==="
            echo "系统类型: $(uname -s)"
            echo "系统架构: $(uname -m)"
            echo "内核版本: $(uname -r)"
            echo "内核版本详细信息: $(uname -v)"
            echo "发行版: $(lsb_release -ds 2>/dev/null || cat /etc/os-release | grep PRETTY_NAME | cut -d= -f2 | tr -d '\"')"
            echo "发行版 ID: $(lsb_release -is 2>/dev/null || cat /etc/os-release | grep ^ID= | cut -d= -f2)"
            echo "版本号: $(lsb_release -rs 2>/dev/null || cat /etc/os-release | grep VERSION_ID | cut -d= -f2 | tr -d '\"')"
            echo "代码名称: $(lsb_release -cs 2>/dev/null || echo 'N/A')"
            
            if grep -q microsoft /proc/version 2>/dev/null; then
                echo "环境: WSL (Windows Subsystem for Linux)"
                echo "WSL 版本: $(uname -r | grep -o 'WSL2' || echo 'WSL1')"
            else
                echo "环境: 原生 Linux"
            fi
            
            echo "启动方式: $(ps -p 1 -o comm=)"
            echo "初始化系统: $(ps -p 1 -o comm=)"
            ;;
        "-s")
            echo "=== 用户信息 ==="
            echo "当前用户: $(whoami)"
            echo "用户 ID: $(id -u)"
            echo "组 ID: $(id -g)"
            echo "所属组: $(id -Gn)"
            echo "主目录: $HOME"
            echo "Shell: $SHELL"
            echo "登录终端: $(tty)"
            echo "登录时间: $(who | grep $(whoami) | awk '{print $3 " " $4}')"
            echo "sudo 权限: $(sudo -n true 2>/dev/null && echo "可用" || echo "不可用/需要密码")"
            echo "最近登录:"
            last -n 3 | head -4
            ;;
        "")
            echo "=== 基本信息 ==="
            echo "主机: $(hostname)"
            echo "用户: $(whoami)"
            echo "发行版: $(lsb_release -ds 2>/dev/null || echo 'Ubuntu 24.04')"
            echo "内核: $(uname -r)"
            echo "架构: $(uname -m)"
            echo "运行时间: $(uptime -p | sed 's/up //')"
            echo "内存总量: $(free -h | awk 'NR==2{print $2}')"
            echo "已用内存: $(free -h | awk 'NR==2{print $3}')"
            echo "可用内存: $(free -h | awk 'NR==2{print $7}')"
            echo "内存使用率: $(free | awk 'NR==2{printf "%.1f%%", $3/$2*100}')"
            echo "存储总量: $(df -h / | awk 'NR==2{print $2}')"
            echo "已用存储: $(df -h / | awk 'NR==2{print $3}')"
            echo "可用存储: $(df -h / | awk 'NR==2{print $4}')"
            echo "存储使用率: $(df -h / | awk 'NR==2{print $5}')"
            
            if grep -q microsoft /proc/version 2>/dev/null; then
                echo "环境: WSL"
                echo "Windows 主机: $(grep nameserver /etc/resolv.conf | awk '{print $2}')"
            else
                echo "环境: 原生 Linux"
            fi
            ;;
        *)
            echo "about 命令用法:"
            echo "  about       - 显示基本信息"
            echo "  about -a    - 显示详细信息"
            echo "  about -c    - 显示处理器信息"
            echo "  about -g    - 显示显卡信息"
            echo "  about -o    - 显示操作系统信息"
            echo "  about -s    - 显示用户信息"
            ;;
    esac
}
command_list() {  #文件列表
    ls -la "$ARGS"
}
command_network() { #查看网络
    case "$ARGS" in
        "-c")
            echo "=== 网卡及连接情况 ==="
            echo "网络接口列表:"
            ip link show
            echo ""
            echo "IP地址信息:"
            ip addr show
            echo ""
            echo "路由表:"
            ip route show
            echo ""
            echo "网络连接:"
            ss -tuln
            ;;
        "-i")
            echo "=== 网络信息 ==="
            echo "WSL IP: $(hostname -I)"
            echo "Windows 主机: $(grep nameserver /etc/resolv.conf | awk '{print $2}')"
            echo "网络接口:"
            ip addr show | grep -E "^\s*[0-9]+:" | awk '{print $2}' | tr -d :
            ;;
        *)
            echo "=== network 命令用法 ==="
            echo "network -c : 显示所有网卡及连接情况（包括虚拟网卡）"
            echo "network -i : 显示基本网络信息"
            ;;
    esac
}
command_disk() { #查看磁盘
    echo "=== 磁盘使用情况 ==="
    df -h | grep -v tmpfs
    case "$ARGS" in
        "-m")
            # 硬盘挂载管理功能
            # 检查root权限
            if [ "$(id -u)" -ne 0 ]; then
                echo "错误: 挂载操作需要 root 权限"
                echo "请使用: sudo disk -m"
                return 1
            fi

            echo "=== 硬盘挂载管理 ==="
            
            # 扫描所有块设备
            echo "正在扫描存储设备..."
            echo ""
            
            # 获取所有块设备信息（包括已挂载和未挂载的）
            local devices=()
            local device_info_list=()
            local i=1
            
            while IFS= read -r line; do
                if [ -n "$line" ]; then
                    local device_name=$(echo "$line" | awk '{print $1}')
                    local device_path="/dev/$device_name"
                    
                    # 获取详细设备信息
                    local size=$(echo "$line" | awk '{print $2}')
                    local fstype=$(echo "$line" | awk '{print $3}')
                    local mountpoint=$(echo "$line" | awk '{print $4}')
                    local label=$(echo "$line" | awk '{print $5}')
                    local model=$(echo "$line" | awk '{print $6}')
                    
                    devices[$i]="$device_path"
                    device_info_list[$i]="$size|$fstype|$mountpoint|$label|$model"
                    
                    if [ -z "$mountpoint" ] || [ "$mountpoint" = "" ]; then
                        echo "  $i) $device_path - ${size} - $fstype - $label - $model - [未挂载]"
                    else
                        echo "  $i) $device_path - ${size} - $fstype - $label - $model - [已挂载: $mountpoint]"
                    fi
                    i=$((i + 1))
                fi
            done < <(lsblk -o NAME,SIZE,FSTYPE,MOUNTPOINT,LABEL,MODEL -r | grep -E "^(sd|nvme|vd)" | grep -v "├\|└")
            
            if [ $i -eq 1 ]; then
                echo "未找到可用的存储设备"
                return 1
            fi
            
            echo ""
            echo -n "请选择要操作的设备 (1-$((i-1))), 或输入 'q' 退出: "
            read -r device_choice
            
            if [ "$device_choice" = "q" ] || [ "$device_choice" = "Q" ]; then
                echo "操作已取消"
                return 0
            fi
            
            if [ "$device_choice" -lt 1 ] || [ "$device_choice" -ge $i ]; then
                echo "错误: 无效的选择"
                return 1
            fi
            
            local selected_device="${devices[$device_choice]}"
            local device_info="${device_info_list[$device_choice]}"
            local size=$(echo "$device_info" | cut -d'|' -f1)
            local fstype=$(echo "$device_info" | cut -d'|' -f2)
            local mountpoint=$(echo "$device_info" | cut -d'|' -f3)
            local label=$(echo "$device_info" | cut -d'|' -f4)
            local model=$(echo "$device_info" | cut -d'|' -f5)
            
            # 检查设备是否已挂载
            if [ -n "$mountpoint" ] && [ "$mountpoint" != "" ]; then
                echo ""
                echo "设备 $selected_device 已挂载到: $mountpoint"
                echo "请选择操作:"
                echo "  1) 卸载设备"
                echo "  2) 重新挂载到其他位置"
                echo "  3) 取消"
                echo -n "请选择 (1-3): "
                read -r operation_choice
                
                case "$operation_choice" in
                    1)
                        echo "正在卸载 $selected_device ..."
                        if umount "$selected_device"; then
                            echo "设备已成功卸载"
                            
                            # 检查是否为fstab中的永久挂载，如果是则询问是否删除
                            if grep -q "$selected_device" /etc/fstab 2>/dev/null; then
                                echo -n "检测到该设备在 /etc/fstab 中有永久挂载配置，是否删除? (y/N): "
                                read -r remove_fstab
                                if [ "$remove_fstab" = "y" ] || [ "$remove_fstab" = "Y" ]; then
                                    sudo sed -i "\|$selected_device|d" /etc/fstab
                                    echo "已从 /etc/fstab 中删除挂载配置"
                                fi
                            fi
                        else
                            echo "卸载失败，设备可能正在使用中"
                        fi
                        ;;
                    2)
                        # 先卸载设备
                        echo "正在卸载 $selected_device ..."
                        if ! umount "$selected_device"; then
                            echo "卸载失败，无法重新挂载"
                            return 1
                        fi
                        echo "设备已成功卸载"
                        # 然后继续挂载流程
                        ;;
                    3)
                        echo "操作已取消"
                        return 0
                        ;;
                    *)
                        echo "无效选择，操作已取消"
                        return 1
                        ;;
                esac
                
                # 如果用户选择了取消或卸载，直接返回
                if [ "$operation_choice" = "1" ] || [ "$operation_choice" = "3" ]; then
                    return 0
                fi
                # 如果用户选择了重新挂载，继续执行下面的挂载流程
            fi
            
            # 挂载流程 - 先询问挂载点
            echo ""
            echo "选择的设备: $selected_device"
            echo ""
            
            # 询问挂载点
            local default_mountpoint="/mnt/$(basename "$selected_device")"
            echo -n "请输入挂载点路径 [默认: $default_mountpoint]: "
            read -r mount_point
            
            if [ -z "$mount_point" ]; then
                mount_point="$default_mountpoint"
            fi
            
            # 显示设备信息
            echo ""
            echo "设备信息:"
            echo "  文件系统: $fstype"
            echo "  大小: $size"
            echo "  标签: $label"
            echo "  型号: $model"
            echo "  挂载点: $mount_point"
            echo ""
            
            # 创建挂载点目录
            if [ ! -d "$mount_point" ]; then
                echo -n "挂载点目录不存在，是否创建? (Y/n): "
                read -r create_dir
                if [ "$create_dir" != "n" ] && [ "$create_dir" != "N" ]; then
                    mkdir -p "$mount_point"
                    if [ $? -ne 0 ]; then
                        echo "错误: 无法创建挂载点目录"
                        return 1
                    fi
                    echo "已创建挂载点目录: $mount_point"
                else
                    echo "操作已取消"
                    return 1
                fi
            fi
            
            # 检查挂载点是否为空
            if [ "$(ls -A "$mount_point" 2>/dev/null)" ]; then
                echo "警告: 挂载点目录 $mount_point 不为空"
                echo -n "是否继续? (y/N): "
                read -r continue_mount
                if [ "$continue_mount" != "y" ] && [ "$continue_mount" != "Y" ]; then
                    echo "操作已取消"
                    return 1
                fi
            fi
            
            # 执行挂载
            echo "正在挂载 $selected_device 到 $mount_point ..."
            if mount "$selected_device" "$mount_point"; then
                echo "设备已成功挂载"
                
                # 询问是否永久挂载
                echo ""
                echo -n "是否设置为永久挂载 (写入 /etc/fstab)? (y/N): "
                read -r permanent_mount
                
                if [ "$permanent_mount" = "y" ] || [ "$permanent_mount" = "Y" ]; then
                    local uuid=$(blkid -s UUID -o value "$selected_device")
                    if [ -n "$uuid" ]; then
                        local fstab_entry="UUID=$uuid $mount_point $fstype defaults 0 2"
                        if ! grep -q "$uuid" /etc/fstab 2>/dev/null; then
                            echo "$fstab_entry" | sudo tee -a /etc/fstab > /dev/null
                            echo "已添加到 /etc/fstab (使用UUID: $uuid)"
                        else
                            echo "该设备已在 /etc/fstab 中存在"
                        fi
                    else
                        echo "无法获取设备UUID，使用设备路径代替"
                        local fstab_entry="$selected_device $mount_point $fstype defaults 0 2"
                        if ! grep -q "$selected_device" /etc/fstab 2>/dev/null; then
                            echo "$fstab_entry" | sudo tee -a /etc/fstab > /dev/null
                            echo "已添加到 /etc/fstab (使用设备路径)"
                        else
                            echo "该设备已在 /etc/fstab 中存在"
                        fi
                    fi
                else
                    echo "此为临时挂载，重启后需要重新挂载"
                fi
                
                # 显示挂载结果
                echo ""
                echo "挂载信息:"
                df -h | grep "$mount_point"
            else
                echo "挂载失败，请检查设备状态和文件系统"
            fi
            ;;
        *)
            echo "=== 磁盘使用情况 ==="
            df -h | grep -v tmpfs
            echo ""
            echo "使用 'disk -m' 管理硬盘挂载"
            ;;
    esac
}
command_ctime() {
    echo "本地时间: $(date +"%Y-%m-%d %H:%M:%S.%N" | cut -c1-23)"
    echo "标准格式: $(date)"
    echo "UNIX时间戳: $(date +%s)"
    local timezone_info=""
    if command -v timedatectl >/dev/null 2>&1; then
        timezone_info=$(timedatectl show --property=Timezone --value 2>/dev/null)
    fi
    
    if [ -n "$timezone_info" ]; then
        echo "系统时区: $timezone_info"
    else
        if [ -f /etc/timezone ]; then
            timezone_info=$(cat /etc/timezone)
            echo "系统时区: $timezone_info"
        elif [ -h /etc/localtime ]; then
            timezone_info=$(readlink /etc/localtime | sed 's|.*/zoneinfo/||')
            echo "系统时区: $timezone_info"
        else
            echo "系统时区: 未知"
        fi
    fi
    local offset=$(date +%z) #显示时区
    if [ -n "$offset" ]; then
        echo "时区: UTC${offset:0:3}:${offset:3:2}"
    fi
    echo "年-月-日: $(date +"%Y-%m-%d")" #显示详细的日期信息
    echo "星期: $(date +"%A")"
    echo "系统运行: $(uptime -p | sed 's/up //')"
    if command -v timedatectl >/dev/null 2>&1; then
        local ntp_sync=$(timedatectl show --property=NTPSynchronized --value 2>/dev/null)
        if [ "$ntp_sync" = "yes" ]; then
            echo "时间同步已启用(WSL环境下与Windows同步)"
        else
            echo "时间同步未启用"
        fi
    fi
    if command -v hwclock >/dev/null 2>&1; then
        echo "硬件时钟: $(hwclock --show 2>/dev/null | cut -d' ' -f1-7 || echo "无法读取")"
    fi
}
command_process() { #查看当前正在运行的所有进程
    case "$ARGS" in
        "list")
            echo "=== 进程列表 (前10个) ==="
            ps aux --sort=-%cpu | head -11
            ;;
        "all")
            ps aux
            ;;
        *)
            echo "用法: process list|all"
            ;;
    esac
}
command_nkill() {
    if [ "$(id -u)" -ne 0 ]; then #检查用户
        echo "错误: nkill 命令必须在 root 用户下使用"
        echo "请使用: sudo nkill [选项] <进程ID>"
        return 1
    fi
    local option="" #解析参数
    local pid=""
    case "$ARGS" in #处理不同参数格式
        -p\ *)
            option="-p" #格式: nkill -p 114514
            pid=$(echo "$ARGS" | awk '{print $2}')
            ;;
        -c\ *)
            option="-c" #格式:nkill -c 114514
            pid=$(echo "$ARGS" | awk '{print $2}')
            ;;
        -p*)
            option="-p" #格式: nkill -p114514
            pid="${ARGS#-p}"
            ;;
        -c*)
            option="-c" #格式: nkill -c114514
            pid="${ARGS#-c}"
            ;;
        *)
            if [[ "$ARGS" =~ ^[0-9]+$ ]]; then #格式: nkill 114514 或 nkill -p 114514（已经处理过）
                pid="$ARGS" #若为数字，直接作为PID
            else
                option="" #其他情况显示用法
                pid=""
            fi
            ;;
    esac
    pid=$(echo "$pid" | tr -d '[:space:]') #去除PID中的空格，规避提取错误
    if [ -z "$pid" ]; then #展示用法
        echo "nkill 命令用法:"
        echo "nkill <进程ID>     - 强制杀死进程"
        echo "nkill -p <进程ID>  - 暂停进程工作"
        echo "nkill -c <进程ID>  - 继续被暂停的进程"
        echo "注意: 所有 nkill 命令必须在 root 用户下使用"
        echo "示例:"
        echo "nkill 114514"
        echo "nkill -p 114514"
        echo "nkill -p114514"
        echo "nkill -c 114514"
        return 1
    fi
    if ! [[ "$pid" =~ ^[0-9]+$ ]]; then #检查PID是否为数字
        echo "错误: 进程ID必须是数字，当前输入: '$pid'"
        return 1
    fi
    if ! ps -p "$pid" > /dev/null 2>&1; then #检查进程是否存在
        echo "错误: 进程 $pid 不存在"
        return 1
    fi
    case "$option" in #判定命令后缀，根据选项要求执行操作
        "-p")
            echo "警告: 您将要暂停进程 $pid" #暂停指定的进程
            echo -n "确定要暂停此进程吗？(y/N): "
            read -r confirm
            if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                if kill -STOP "$pid"; then
                    echo "已暂停进程: $pid"
                else
                    echo "暂停进程失败: $pid"
                fi
            else
                echo "操作已取消"
            fi
            ;;
        "-c")
            echo "警告: 您将要继续进程 $pid" #继续被暂停的进程
            echo -n "确定要继续此进程吗？(y/N): "
            read -r confirm
            if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                if kill -CONT "$pid"; then
                    echo "继续进程: $pid"
                else
                    echo "继续进程失败: $pid"
                fi
            else
                echo "操作已取消"
            fi
            ;;
        *)
            local process_info=$(ps -p "$pid" -o pid,user,comm,cmd --no-headers 2>/dev/null) #强制杀死进程
            echo "警告: 您将要强制杀死进程 $pid"
            echo "进程信息: $process_info"
            echo -n "确定要强制杀死此进程吗？(y/N): "
            read -r confirm
            if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                if kill -9 "$pid"; then
                    echo "已杀死进程: $pid"
                else
                    echo "杀死进程失败: $pid"
                fi
            else
                echo "操作已取消"
            fi
            ;;
    esac
}
command_open() {
    if [ -z "$ARGS" ]; then
        echo "open 命令用法:"
        echo "  open <文件路径> - 在命令行环境中打开指定文件"
        echo ""
        echo "支持的文件类型:"
        echo "  文本文件 (.txt, .log, .conf, .sh, .py, .js, .html, .css, .json, .xml 等)"
        echo "  代码文件 (.c, .cpp, .java, .php, .rb, .go, .rs 等)"
        echo "  配置文件 (.ini, .cfg, .yml, .yaml, .toml 等)"
        echo "  文档文件 (.md, .rst, .tex 等)"
        echo ""
        echo "示例:"
        echo "  open document.txt"
        echo "  open script.sh"
        echo "  open /etc/hosts"
        return 1
    fi
    local file_path="$ARGS"
    if [ ! -e "$file_path" ]; then
        echo "文件 '$file_path' 不存在"
        return 1
    fi
    if [ ! -f "$file_path" ]; then
        echo "'$file_path' 不是文件，这可能是一个目录或不可用的位置"
        return 1
    fi
    if [ ! -r "$file_path" ]; then
        echo "您没有访问 '$file_path' 的权限"
        return 1
    fi
    echo "正在打开: $file_path"
    local file_type=$(file -b "$file_path" 2>/dev/null)
    if [ $? -ne 0 ]; then
        file_type="未知文件类型"
    fi
    if file "$file_path" | grep -q "text"; then
        if command -v less >/dev/null 2>&1; then
            less "$file_path"
        elif command -v more >/dev/null 2>&1; then
            more "$file_path"
        elif command -v nano >/dev/null 2>&1; then
            nano "$file_path"
        elif command -v vim >/dev/null 2>&1; then
            vim "$file_path"
        elif command -v vi >/dev/null 2>&1; then
            vi "$file_path"
        else
            cat "$file_path"
        fi
        return 0
    else
        echo "该文件类型不受支持"
        echo "检测到的文件类型: $file_type"
        return 1
    fi
}
command_delete() {
    if [ -z "$ARGS" ]; then
        echo "delete 命令用法:"
        echo "  delete <路径> - 删除指定的文件或目录"
        echo ""
        echo "注意: 删除操作不可逆，请谨慎使用"
        echo ""
        echo "示例:"
        echo "  delete file.txt"
        echo "  delete /path/to/directory"
        echo "  delete /path/to/file"
        return 1
    fi
    local target_path="$ARGS"
        if [ ! -e "$target_path" ]; then
        echo "错误: 路径 '$target_path' 不存在"
        return 1
    fi
    local item_type=""
    local item_info=""
    
    if [ -f "$target_path" ]; then
        item_type="文件"
        item_info="大小: $(du -h "$target_path" | cut -f1)"
    elif [ -d "$target_path" ]; then
        item_type="目录"
        local file_count=$(find "$target_path" -type f 2>/dev/null | wc -l)
        local dir_count=$(find "$target_path" -type d 2>/dev/null | wc -l)
        item_info="包含: $file_count 个文件, $(($dir_count - 1)) 个子目录"
    elif [ -L "$target_path" ]; then
        item_type="符号链接"
        item_info="指向: $(readlink "$target_path")"
    else
        item_type="特殊文件"
    fi
    echo "类型: $item_type"
    echo "路径: $target_path"
    if [ -n "$item_info" ]; then
        echo "信息: $item_info"
    fi
    echo "警告: 此操作不可逆!"
    echo -n "确定要删除吗？(y|N): "
    read -r user_confirm
    if [ "$user_confirm" != "y" ]; then
        echo "操作已取消"
        return 0
    fi
    echo "正在删除..."
    if [ -f "$target_path" ] || [ -L "$target_path" ]; then
        if rm -f "$target_path"; then
            echo "已删除 $item_type: $target_path"
        else
            echo "删除失败: $target_path"
            return 1
        fi
    elif [ -d "$target_path" ]; then
        if rm -rf "$target_path"; then
            echo "已删除目录: $target_path"
        else
            echo "删除目录失败: $target_path"
            return 1
        fi
    else
        echo "无法识别的文件类型: $target_path"
        return 1
    fi
    return 0
}
command_new() {
    if [ -z "$ARGS" ]; then
        echo "new 命令用法:"
        echo "new <路径> - 新建目录或文件"
        return 1
    fi
    local target_path="$ARGS"
    if [ -e "$target_path" ]; then #检查路径是否已存在
        echo "路径 '$target_path' 已存在，无法重复创建"
        return 1
    fi
    echo "路径: $target_path"
    echo "请选择要创建的类型:"
    echo " 1) 目录 (directory)"
    echo " 2) 文件 (file)"
    echo -n "请输入选项 (1 或 2): "
    read -r user_choice
    case "$user_choice" in #根据用户选择执行相应操作
        1|directory|dir|d)
            echo "正在创建目录..."
            if mkdir -p "$target_path"; then
                echo "已创建目录: $target_path"
                
                # 显示目录权限信息
                local perm=$(stat -c "%a" "$target_path" 2>/dev/null || echo "未知")
                echo "权限: $perm"
            else
                echo "创建目录失败: $target_path，可能该目录已存在或您没有访问其上级目录的权限"
                return 1
            fi
            ;;
        2|file|f)
            echo "正在创建文件..."
            local parent_dir=$(dirname "$target_path") #确保父目录存在
            if [ ! -d "$parent_dir" ]; then
                echo "父目录不存在，自动创建: $parent_dir"
                mkdir -p "$parent_dir"
            fi
            if touch "$target_path"; then #创建空文件
                echo "✓ 已创建文件: $target_path"
                local perm=$(stat -c "%a" "$target_path" 2>/dev/null || echo "未知")
                local size=$(du -h "$target_path" | cut -f1)
                echo "权限: $perm"
                echo "大小: $size"
                echo ""
                echo -n "是否立即编辑文件内容？(y/N): "
                read -r edit_choice
                if [ "$edit_choice" = "y" ] || [ "$edit_choice" = "Y" ]; then
                    if command -v nano >/dev/null 2>&1; then
                        nano "$target_path"
                    elif command -v vim >/dev/null 2>&1; then
                        vim "$target_path"
                    elif command -v vi >/dev/null 2>&1; then
                        vi "$target_path"
                    else
                        echo "未找到可用的文本编辑器"
                    fi
                fi
            else
                echo "创建文件失败: $target_path，您可能没有访问其目录的权限"
                return 1
            fi
            ;;
        *)
            echo "无效的选择，操作已取消"
            return 1
            ;;
    esac
    
    return 0
}
command_mod() {
    if [ -z "$ARGS" ]; then
        echo "mod 命令用法:"
        echo "  mod <路径> - 修改文件或目录的属性"
        echo ""
        echo "可修改的属性:"
        echo "  - 文件权限 (chmod)"
        echo "  - 所有者和组 (chown)"
        echo "  - 时间戳 (touch)"
        echo "  - 重命名 (mv)"
        echo ""
        echo "示例:"
        echo "  mod file.txt"
        echo "  mod /path/to/directory"
        echo "  mod script.sh"
        return 1
    fi
    local target_path="$ARGS"
    if [ ! -e "$target_path" ]; then
        echo "错误: 路径 '$target_path' 不存在"
        return 1
    fi
    echo "=== 当前属性 ==="
    if [ -f "$target_path" ]; then
        echo "类型: 文件"
    elif [ -d "$target_path" ]; then
        echo "类型: 目录"
    elif [ -L "$target_path" ]; then
        echo "类型: 符号链接"
    else
        echo "类型: 特殊文件"
    fi
    echo "路径: $target_path"
    echo "权限: $(stat -c "%A (%a)" "$target_path" 2>/dev/null || echo "未知")"
    echo "所有者: $(stat -c "%U:%G" "$target_path" 2>/dev/null || echo "未知")"
    echo "大小: $(du -h "$target_path" | cut -f1)"
    echo "修改时间: $(stat -c "%y" "$target_path" 2>/dev/null || echo "未知")"
    echo "  1) 修改权限 (chmod)"
    echo "  2) 修改所有者和组 (chown)"
    echo "  3) 修改时间戳 (touch)"
    echo "  4) 重命名/移动 (mv)"
    echo "  5) 取消"
    echo ""
    echo -n "请选择操作 (1-5): "
    read -r user_choice
    case "$user_choice" in
        1)
            echo ""
            echo "当前权限: $(stat -c "%A (%a)" "$target_path")"
            echo ""
            echo "权限示例:"
            echo "  755 - 所有者:读/写/执行, 组:读/执行, 其他:读/执行"
            echo "  644 - 所有者:读/写, 组:读, 其他:读"
            echo "  777 - 所有用户:读/写/执行 (不推荐)"
            echo ""
            echo -n "请输入新的权限 (如 755): "
            read -r new_perms
            if [[ ! "$new_perms" =~ ^[0-7]{3,4}$ ]]; then
                echo "错误: 无效的权限格式 '$new_perms'"
                echo "权限必须是 3 或 4 位八进制数字 (如 755 或 0755)"
                return 1
            fi
            echo -n "确认将 '$target_path' 的权限改为 $new_perms? (y/N): "
            read -r confirm
            if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                if chmod "$new_perms" "$target_path"; then
                    echo "权限已修改: $(stat -c "%A (%a)" "$target_path")"
                else
                    echo "修改权限失败，可能需要 root 权限"
                    echo "尝试使用: sudo chmod $new_perms '$target_path'"
                fi
            else
                echo "操作已取消"
            fi
            ;;
        2)
            echo "当前所有者: $(stat -c "%U:%G" "$target_path")"
            echo -n "请输入新的所有者 (格式: 用户:组 或 用户): "
            read -r new_owner
            if [[ ! "$new_owner" =~ ^[a-zA-Z0-9_.-]+(:[a-zA-Z0-9_.-]+)?$ ]]; then
                echo "错误: 无效的所有者格式 '$new_owner'"
                echo "格式应为: 用户名 或 用户名:组名"
                return 1
            fi
            echo -n "确认将 '$target_path' 的所有者改为 $new_owner? (y/N): "
            read -r confirm
            if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                if chown "$new_owner" "$target_path"; then
                    echo "所有者已修改: $(stat -c "%U:%G" "$target_path")"
                else
                    echo "修改所有者失败，可能需要 root 权限"
                    echo "尝试使用: sudo chown $new_owner '$target_path'"
                fi
            else
                echo "操作已取消"
            fi
            ;;
        3)
            echo "当前修改时间: $(stat -c "%y" "$target_path")"
            echo "当前访问时间: $(stat -c "%x" "$target_path")"
            echo "时间戳选项:"
            echo "  1) 设置为当前时间"
            echo "  2) 设置为特定时间"
            echo "  3) 仅修改访问时间"
            echo "  4) 仅修改修改时间"
            echo -n "请选择时间戳操作 (1-4): "
            read -r time_choic
            case "$time_choice" in
                1)
                    if touch "$target_path"; then
                        echo "时间戳已更新为当前时间"
                        echo "新修改时间: $(stat -c "%y" "$target_path")"
                    else
                        echo "更新时间戳失败，请检查操作是否合法或您是否有修改权限"
                    fi
                    ;;
                2)
                    echo -n "请输入时间 (格式: YYYYMMDDhhmm.ss): "
                    read -r specific_time
                    if touch -t "$specific_time" "$target_path"; then
                        echo "时间戳已设置为: $specific_time"
                        echo "新修改时间: $(stat -c "%y" "$target_path")"
                    else
                        echo "设置时间戳失败，格式应为: YYYYMMDDhhmm.ss"
                    fi
                    ;;
                3)
                    if touch -a "$target_path"; then
                        echo "访问时间已更新为当前时间"
                        echo "新访问时间: $(stat -c "%x" "$target_path")"
                    else
                        echo "更新访问时间失败，请检查操作是否合法或您是否有修改权限"
                    fi
                    ;;
                4)
                    if touch -m "$target_path"; then
                        echo "修改时间已更新为当前时间"
                        echo "新修改时间: $(stat -c "%y" "$target_path")"
                    else
                        echo "更新修改时间失败，请检查操作是否合法或您是否有修改权限"
                    fi
                    ;;
                *)
                    echo "无效选择，操作已取消"
                    ;;
            esac
            ;;
        4)
            echo "当前路径: $target_path"
            echo -n "请输入新路径: "
            read -r new_path
            if [ -z "$new_path" ]; then
                echo "错误: 新路径不能为空"
                return 1
            fi
            if [ -e "$new_path" ]; then
                echo "警告: '$new_path' 已存在"
                echo -n "是否覆盖? (y/N): "
                read -r overwrite
                if [ "$overwrite" != "y" ] && [ "$overwrite" != "Y" ]; then
                    echo "操作已取消"
                    return 0
                fi
            fi
            echo -n "确认将 '$target_path' 移动到 '$new_path'? (y/N): "
            read -r confirm
            if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                if mv "$target_path" "$new_path"; then
                    echo "已移动/重命名: $new_path"
                    target_path="$new_path"
                else
                    echo "移动/重命名失败，请检查操作是否合法或您是否有修改权限"
                fi
            else
                echo "操作已取消"
            fi
            ;;
        5)
            echo "操作已取消"
            return 0
            ;;
        *)
            echo "无效选择，操作已取消"
            return 1
            ;;
    esac
    return 0
}
command_driver() {
    local need_root=false
    case "$ARGS" in
        "-i"*|"-d"*)
            need_root=true
            ;;
    esac
    if [ "$need_root" = true ] && [ "$(id -u)" -ne 0 ]; then
        echo "错误: 此操作需要 root 权限"
        echo "请使用: sudo driver $ARGS"
        return 1
    fi
    case "$ARGS" in
                "-r")
            echo "正在扫描所有驱动程序，请稍候..."
            if [ ! -d "/lib/modules/$(uname -r)" ]; then
                echo "警告: 未找到内核模块目录，可能在某些其他环境中（如容器）"
                echo "将显示可用信息..."
                echo ""
            fi
            local loaded_modules=()
            if command -v lsmod >/dev/null 2>&1; then
                loaded_modules=($(lsmod | awk 'NR>1 {print $1}'))
                echo "发现 ${#loaded_modules[@]} 个已加载的驱动程序"
                echo ""
            else
                echo "错误: lsmod 命令不可用"
                return 1
            fi
            printf "%-25s | %-20s | %-25s | %-15s\n" "驱动名称" "发行商" "加载时间" "状态"
            printf "%-25s-+-%-20s-+-%-25s-+-%-15s\n" "-------------------------" "--------------------" "-------------------------" "---------------"
            local count=0
            for module in "${loaded_modules[@]}"; do
                local module_info=$(modinfo "$module" 2>/dev/null)
                local vendor=$(echo "$module_info" | grep -i "vendor" | head -1 | cut -d: -f2- | sed 's/^ *//')
                local description=$(echo "$module_info" | grep -i "description" | head -1 | cut -d: -f2- | sed 's/^ *//')
                local license=$(echo "$module_info" | grep -i "license" | head -1 | cut -d: -f2- | sed 's/^ *//')
                if [ -z "$vendor" ]; then
                    if [ -n "$description" ]; then
                        vendor="$description"
                    elif [ -n "$license" ]; then
                        vendor="License: $license"
                    else
                        vendor="未知"
                    fi
                fi
                if [ ${#vendor} -gt 18 ]; then
                    vendor="${vendor:0:18}.."
                fi
                local load_time=""
                if [ -d "/sys/module/$module" ]; then
                    load_time=$(stat -c %y "/sys/module/$module" 2>/dev/null | cut -d. -f1)
                fi
                if [ -z "$load_time" ]; then
                    load_time="未知"
                fi
                local status="正常"
                if dmesg | grep -i "error.*$module" >/dev/null 2>&1; then
                    status="错误"
                elif dmesg | grep -i "warn.*$module" >/dev/null 2>&1; then
                    status="警告"
                fi
                printf "%-25s | %-20s | %-25s | %-15s\n" "$module" "$vendor" "$load_time" "$status"
                count=$((count + 1))
                if [ $count -eq 20 ]; then
                    echo ""
                    echo "已显示 20 个驱动程序，总共 ${#loaded_modules[@]} 个..."
                    echo -n "按 Enter 继续显示，或输入 'q' 退出: "
                    read -r user_input
                    if [ "$user_input" = "q" ] || [ "$user_input" = "Q" ]; then
                        echo "显示已终止"
                        break
                    fi
                    printf "%-25s | %-20s | %-25s | %-15s\n" "驱动名称" "发行商" "加载时间" "状态"
                    printf "%-25s-+-%-20s-+-%-25s-+-%-15s\n" "-------------------------" "--------------------" "-------------------------" "---------------"
                fi
            done
            echo "已加载驱动程序: ${#loaded_modules[@]} 个"
            local available_modules=()
            if command -v modprobe >/dev/null 2>&1 && [ -d "/lib/modules/$(uname -r)" ]; then
                available_modules=($(find /lib/modules/$(uname -r) -name "*.ko" -exec basename {} .ko \; 2>/dev/null))
                local loaded_count=${#loaded_modules[@]}
                local available_count=${#available_modules[@]}
                local not_loaded_count=$((available_count - loaded_count))
                echo "可用驱动程序: $available_count 个"
                echo "未成功加载驱动程序: $not_loaded_count 个"
                echo "若在WSL环境中，无法正常扫描驱动属正常现象"
                if [ $not_loaded_count -gt 0 ]; then
                    local displayed=0
                    for module in "${available_modules[@]}"; do
                        if [[ ! " ${loaded_modules[@]} " =~ " ${module} " ]]; then
                            printf "%s " "$module"
                            displayed=$((displayed + 1))
                            if [ $displayed -ge 10 ]; then
                                break
                            fi
                        fi
                    done
                    echo ""
                    echo "... 还有更多未加载驱动"
                fi
            fi
            echo ""
            echo "使用 'modinfo <驱动名称>' 查看详细驱动信息"
            ;;
        "-i")
            if command -v ubuntu-drivers >/dev/null 2>&1; then
                echo "正在检测可用驱动..."
                ubuntu-drivers devices
                echo ""
                echo "正在安装推荐的驱动..."
                sudo ubuntu-drivers autoinstall
                echo "驱动安装完成，建议重启系统"
            elif command -v apt >/dev/null 2>&1; then
                echo "使用 apt 安装通用驱动..."
                echo "正在更新软件包列表..."
                sudo apt update
                echo ""
                echo "安装硬件支持包..."
                sudo apt install -y linux-firmware firmware-linux-free firmware-linux-nonfree
                echo ""
                echo "安装常用驱动..."
                sudo apt install -y alsa-base pulseaudio
                echo "基础驱动安装完成"
            else
                echo "错误: 未找到可用的驱动管理工具"
                echo "请手动安装驱动或检查系统包管理器"
            fi
            ;;
        -i*)
            local driver_name="${ARGS#-i}"
            if [ -z "$driver_name" ]; then
                echo "错误: 未指定驱动名称"
                echo "用法: driver -i<驱动名称>"
                return 1
            fi
            if modinfo "$driver_name" >/dev/null 2>&1; then
                echo "驱动 $driver_name 已存在于系统中"
                echo "尝试加载驱动..."
                if sudo modprobe "$driver_name"; then
                    echo "驱动 $driver_name 加载成功"
                else
                    echo "驱动 $driver_name 加载失败"
                fi
                return 0
            fi
            if command -v apt >/dev/null 2>&1; then
                echo "正在搜索驱动包..."
                local pkg_name=""
                case "$driver_name" in
                    *nvidia*)
                        pkg_name="nvidia-driver-535"
                        ;;
                    *amd*|*radeon*)
                        pkg_name="xserver-xorg-video-radeon"
                        ;;
                    *intel*)
                        pkg_name="xserver-xorg-video-intel"
                        ;;
                    *broadcom*|*bcm*)
                        pkg_name="bcmwl-kernel-source"
                        ;;
                    *realtek*|*rtl*)
                        pkg_name="firmware-realtek"
                        ;;
                    *)
                        pkg_name="$driver_name"
                        ;;
                esac
                echo "尝试安装包: $pkg_name"
                if sudo apt install -y "$pkg_name"; then
                    echo "驱动安装完成"
                    echo "尝试加载驱动..."
                    if sudo modprobe "$driver_name" 2>/dev/null; then
                        echo "驱动 $driver_name 加载成功"
                    else
                        echo "驱动安装完成但加载失败，可能需要重启"
                    fi
                else
                    echo "驱动安装失败"
                    echo "请检查驱动名称或手动安装"
                fi
            else
                echo "错误: 不支持的包管理器"
                echo "请手动安装驱动: $driver_name"
            fi
            ;;
        -d*)
            local driver_name="${ARGS#-d}"
            if [ -z "$driver_name" ]; then
                echo "错误: 未指定驱动名称"
                echo "用法: driver -d<驱动名称>"
                return 1
            fi
            echo "删除驱动: $driver_name ==="
            if lsmod | grep -q "$driver_name"; then
                echo "正在卸载驱动模块..."
                if sudo modprobe -r "$driver_name"; then
                    echo "驱动模块已卸载"
                else
                    echo "驱动模块卸载失败，可能有其他模块共同使用"
                    echo "尝试强制卸载..."
                    if sudo rmmod "$driver_name"; then
                        echo "驱动模块已强制卸载"
                    else
                        echo "强制卸载失败，请手动卸载"
                    fi
                fi
            else
                echo "驱动 $driver_name 未加载"
            fi
            if command -v apt >/dev/null 2>&1; then
                echo "通过 apt 查找相关包..."
                local pkg_name=$(dpkg -l | grep -i "$driver_name" | awk '{print $2}' | head -1)
                
                if [ -n "$pkg_name" ]; then
                    echo "找到相关包: $pkg_name"
                    echo -n "确认删除此包? (y/N): "
                    read -r confirm
                    if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                        sudo apt remove -y "$pkg_name"
                        echo "包 $pkg_name 已删除"
                    else
                        echo "包删除已取消"
                    fi
                else
                    echo "未找到与 $driver_name 相关的安装包"
                fi
            else
                echo "注意: 仅卸载了驱动模块，未删除安装包"
            fi
            ;;
        "")
            echo "已加载的内核模块:"
            if command -v lsmod >/dev/null 2>&1; then
                lsmod | awk 'NR<=20 {printf "  %-30s %s\n", $1, $3}'
            else
                echo "  lsmod 命令不可用"
            fi
            echo "设备驱动信息:"
            if command -v lspci >/dev/null 2>&1; then
                local gpu_driver=$(lspci -k | grep -A 2 -i "VGA\|3D" | grep "Kernel driver" | cut -d: -f2 | sed 's/^ *//')
                if [ -n "$gpu_driver" ]; then
                    echo "  显卡驱动: $gpu_driver"
                else
                    echo "  显卡驱动: 未检测到"
                fi
            fi
            if [ -d "/proc/asound" ]; then
                local sound_driver=$(cat /proc/asound/version 2>/dev/null | head -1)
                if [ -n "$sound_driver" ]; then
                    echo "  声卡驱动: $sound_driver"
                else
                    echo "  声卡驱动: **^#%"
                fi
            fi
            if command -v ethtool >/dev/null 2>&1; then
                local net_interfaces=$(ip link show | grep -E "^[0-9]+:" | grep -v lo | awk -F: '{print $2}' | sed 's/^ *//')
                for iface in $net_interfaces; do
                    local driver=$(ethtool -i "$iface" 2>/dev/null | grep driver | cut -d: -f2 | sed 's/^ *//')
                    if [ -n "$driver" ]; then
                        echo "  网络接口 $iface: $driver"
                    fi
                done
            fi
            echo "使用 'driver -r' 扫描所有硬件驱动"
            echo "使用 'driver -i' 自动安装缺失的驱动"
            ;;
        *)
            echo "driver 命令用法:"
            echo "  driver         - 列出当前已安装的驱动程序"
            echo "  driver -r      - 扫描所有硬件驱动（已安装和缺失的）"
            echo "  driver -i      - 自动安装缺失的驱动"
            echo "  driver -i<名称> - 安装指定的驱动"
            echo "  driver -d<名称> - 删除指定的驱动"
            echo ""
            echo "示例:"
            echo "  driver"
            echo "  driver -r"
            echo "  driver -i"
            echo "  driver -invidia"
            echo "  driver -dbcmwl"
            ;;
    esac
    
    return 0
}
command_backup() {
    local backup_config="$HOME/.mycommands/backup_config"
    local backup_log="$HOME/.mycommands/backup.log"
    mkdir -p "$(dirname "$backup_config")"
    echo "请选择备份类型:"
    echo "  1) 完全备份 - 备份所有文件"
    echo "  2) 增量备份 - 只备份上次备份后修改的文件"
    echo "  3) 差异备份 - 备份上次完全备份后修改的文件"
    echo "  4) 查看备份历史"
    echo "  5) 恢复备份"
    echo -n "请选择 (1-5): "
    read -r backup_choice
    case "$backup_choice" in
        1|2|3)
            echo ""
            echo -n "请输入要备份的源目录路径: "
            read -r source_dir
            if [ ! -d "$source_dir" ]; then
                echo "错误: 源目录 '$source_dir' 不存在"
                return 1
            fi
            echo -n "请输入备份存储目录路径: "
            read -r backup_dir
            if [ ! -d "$backup_dir" ]; then
                echo -n "备份目录不存在，是否创建? (y/N): "
                read -r create_dir
                if [ "$create_dir" = "y" ] || [ "$create_dir" = "Y" ]; then
                    mkdir -p "$backup_dir" || {
                        echo "错误: 无法创建备份目录"
                        return 1
                    }
                else
                    echo "操作已取消"
                    return 1
                fi
            fi
            local backup_type=""
            case "$backup_choice" in
                1) backup_type="full" ;;
                2) backup_type="incremental" ;;
                3) backup_type="differential" ;;
            esac
            local timestamp=$(date +"%Y%m%d_%H%M%S")
            local backup_name="backup_${backup_type}_${timestamp}"
            local backup_path="$backup_dir/$backup_name"
            mkdir -p "$backup_path" || {
                echo "错误: 无法创建备份目录 '$backup_path'，请注意权限"
                return 1
            }
            echo "开始备份..."
            echo "源目录: $source_dir"
            echo "备份到: $backup_path"
            echo "备份类型: $backup_type"
            local backup_count=0
            local total_size=0
            case "$backup_type" in
                "full")   
                    echo "执行完全备份..."
                    while IFS= read -r -d '' file; do
                        if [ -f "$file" ]; then
                            local rel_path="${file#$source_dir/}"
                            local target_dir="$backup_path/$(dirname "$rel_path")"
                            mkdir -p "$target_dir"
                            if cp -p "$file" "$backup_path/$rel_path" 2>/dev/null; then
                                backup_count=$((backup_count + 1))
                                local file_size=$(stat -c%s "$file" 2>/dev/null || echo "0")
                                total_size=$((total_size + file_size))
                                printf "\r已备份: %d 个文件, 总大小: %.2f MB" "$backup_count" "$(echo "scale=2; $total_size/1024/1024" | bc -q 2>/dev/null || echo "0")"
                            fi
                        fi
                    done < <(find "$source_dir" -type f -print0 2>/dev/null)
                    ;;
                "incremental")
                    echo "执行增量备份..."
                    local last_backup_time=""
                    if [ -f "$backup_log" ]; then
                        last_backup_time=$(grep "BACKUP_COMPLETED" "$backup_log" | tail -1 | cut -d'|' -f3)
                    fi
                    if [ -z "$last_backup_time" ]; then
                        echo "警告: 未找到上次备份记录，已自动执行执行完全备份"
                        backup_type="full"
                        command_backup
                        return 0
                    fi
                    while IFS= read -r -d '' file; do
                        if [ -f "$file" ]; then
                            local file_mtime=$(stat -c%Y "$file" 2>/dev/null)
                            if [ "$file_mtime" -gt "$last_backup_time" ]; then
                                local rel_path="${file#$source_dir/}"
                                local target_dir="$backup_path/$(dirname "$rel_path")"
                                mkdir -p "$target_dir"
                                if cp -p "$file" "$backup_path/$rel_path" 2>/dev/null; then
                                    backup_count=$((backup_count + 1))
                                    local file_size=$(stat -c%s "$file" 2>/dev/null || echo "0")
                                    total_size=$((total_size + file_size))
                                    printf "\r已备份: %d 个文件, 总大小: %.2f MB" "$backup_count" "$(echo "scale=2; $total_size/1024/1024" | bc -q 2>/dev/null || echo "0")"
                                fi
                            fi
                        fi
                    done < <(find "$source_dir" -type f -print0 2>/dev/null)
                    ;;
                "differential")
                    echo "执行差异备份..."
                    local last_full_backup_time=""
                    if [ -f "$backup_log" ]; then
                        last_full_backup_time=$(grep "full.*BACKUP_COMPLETED" "$backup_log" | tail -1 | cut -d'|' -f3)
                    fi
                    
                    if [ -z "$last_full_backup_time" ]; then
                        echo "警告: 未找到完全备份记录，执行完全备份"
                        backup_type="full"
                        command_backup
                        return 0
                    fi
                    while IFS= read -r -d '' file; do
                        if [ -f "$file" ]; then
                            local file_mtime=$(stat -c%Y "$file" 2>/dev/null)
                            if [ "$file_mtime" -gt "$last_full_backup_time" ]; then
                                local rel_path="${file#$source_dir/}"
                                local target_dir="$backup_path/$(dirname "$rel_path")"
                                mkdir -p "$target_dir"
                                if cp -p "$file" "$backup_path/$rel_path" 2>/dev/null; then
                                    backup_count=$((backup_count + 1))
                                    local file_size=$(stat -c%s "$file" 2>/dev/null || echo "0")
                                    total_size=$((total_size + file_size))
                                    printf "\r已备份: %d 个文件, 总大小: %.2f MB" "$backup_count" "$(echo "scale=2; $total_size/1024/1024" | bc -q 2>/dev/null || echo "0")"
                                fi
                            fi
                        fi
                    done < <(find "$source_dir" -type f -print0 2>/dev/null)
                    ;;
            esac
            echo "备份完成!"
            echo "备份位置: $backup_path"
            echo "备份文件数: $backup_count"
            echo "总大小: $(echo "scale=2; $total_size/1024/1024" | bc -q 2>/dev/null || echo "0") MB"
            local log_time=$(date +%s)
            echo "$(date '+%Y-%m-%d %H:%M:%S')|$backup_type|$log_time|$source_dir|$backup_path|$backup_count|$total_size|BACKUP_COMPLETED" >> "$backup_log"
            ;;
        4)
            if [ -f "$backup_log" ]; then
                printf "%-19s | %-12s | %-30s | %-8s | %s\n" "时间" "类型" "源目录" "文件数" "备份位置"
                printf "%-19s-+-%-12s-+-%-30s-+-%-8s-+-%s\n" "-------------------" "------------" "------------------------------" "--------" "------------------------------"
                while IFS='|' read -r date type time source target count size status; do
                    if [ "$status" = "BACKUP_COMPLETED" ]; then
                        local short_source=$(echo "$source" | cut -c1-30)
                        local short_target=$(basename "$target")
                        printf "%-19s | %-12s | %-30s | %-8s | %s\n" "$date" "$type" "$short_source" "$count" "$short_target"
                    fi
                done < "$backup_log"
            else
                echo "暂无备份记录"
            fi
            ;;
        5)
            if [ ! -f "$backup_log" ]; then
                echo "错误: 未找到备份记录"
                return 1
            fi
            echo "可恢复的备份:"
            local i=1
            local restore_options=()
            while IFS='|' read -r date type time source target count size status; do
                if [ "$status" = "BACKUP_COMPLETED" ]; then
                    echo "  $i) $date - $type - $source -> $(basename "$target")"
                    restore_options[$i]="$target|$source"
                    i=$((i + 1))
                fi
            done < "$backup_log"
            
            if [ $i -eq 1 ]; then
                echo "没有可恢复的备份"
                return 1
            fi
            echo -n "请选择要恢复的备份 (1-$((i-1))): "
            read -r restore_choice
            
            if [ "$restore_choice" -lt 1 ] || [ "$restore_choice" -ge $i ]; then
                echo "错误: 无效的选择"
                return 1
            fi
            local restore_info="${restore_options[$restore_choice]}"
            local restore_target=$(echo "$restore_info" | cut -d'|' -f1)
            local restore_source=$(echo "$restore_info" | cut -d'|' -f2)
            echo "恢复信息:"
            echo "  备份位置: $restore_target"
            echo "  恢复到: $restore_source"
            echo -n "确认恢复? 此操作将覆盖现有文件! (y/N): "
            read -r confirm_restore
            if [ "$confirm_restore" != "y" ] && [ "$confirm_restore" != "Y" ]; then
                echo "恢复已取消"
                return 0
            fi
            echo "开始恢复..."
            local restore_count=0
            if [ -d "$restore_target" ]; then
                while IFS= read -r -d '' file; do
                    if [ -f "$file" ]; then
                        local rel_path="${file#$restore_target/}"
                        local target_path="$restore_source/$rel_path"
                        local target_dir="$(dirname "$target_path")"
                        
                        mkdir -p "$target_dir"
                        if cp -p "$file" "$target_path" 2>/dev/null; then
                            restore_count=$((restore_count + 1))
                            printf "\r已恢复: %d 个文件" "$restore_count"
                        fi
                    fi
                done < <(find "$restore_target" -type f -print0 2>/dev/null)
                echo ""
                echo "恢复完成! 共恢复 $restore_count 个文件"
            else
                echo "错误: 备份目录不存在"
            fi
            ;;
        *)
            echo "无效选择"
            return 1
            ;;
    esac
    return 0
}
command_check() {
    case "$ARGS" in
        "-f")
            echo -n "请输入代码文件路径: "
            read -r code_file
            if [ -z "$code_file" ]; then
                echo "错误: 未指定文件路径"
                return 1
            fi
            if [ ! -f "$code_file" ]; then
                echo "错误: 文件 '$code_file' 不存在"
                return 1
            fi
            if [ ! -r "$code_file" ]; then
                echo "错误: 没有读取 '$code_file' 的权限"
                return 1
            fi
            echo "正在检查: $code_file"
            local extension="${code_file##*.}"
            extension=$(echo "$extension" | tr '[:upper:]' '[:lower:]')
            case "$extension" in
                "sh"|"bash")
                    echo "检查 Shell 脚本格式..."
                    if command -v shellcheck >/dev/null 2>&1; then
                        shellcheck "$code_file"
                        local shellcheck_result=$?
                        if [ $shellcheck_result -eq 0 ]; then
                            echo "Shell 脚本格式正确"
                        else
                            echo "Shell 脚本存在格式问题"
                        fi
                    else
                        echo "提示: 安装 shellcheck 可以获得更详细的检查"
                        echo "sudo apt install shellcheck"
                        echo "基础语法检查:"
                        if bash -n "$code_file" 2>/dev/null; then
                            echo "基础语法正确"
                        else
                            echo "基础语法错误"
                            bash -n "$code_file"
                        fi
                    fi
                    ;;
                "py")
                    echo "检查 Python 代码格式..."
                    if command -v python3 >/dev/null 2>&1; then
                        if python3 -m py_compile "$code_file" 2>/dev/null; then
                            echo "Python 语法正确"
                            local pyc_file="${code_file}c"
                            [ -f "$pyc_file" ] && rm -f "$pyc_file"
                        else
                            echo "Python 语法错误"
                            python3 -m py_compile "$code_file"
                        fi
                    else
                        echo "错误: 未找到 python3"
                    fi
                    if command -v flake8 >/dev/null 2>&1; then
                        echo ""
                        echo "PEP8 格式检查:"
                        flake8 "$code_file" --max-line-length=120
                    fi
                    ;;
                "js")
                    echo "检查 JavaScript 代码格式..."
                    if command -v node >/dev/null 2>&1; then
                        if node -c "$code_file" 2>/dev/null; then
                            echo "JavaScript 语法正确"
                        else
                            echo "JavaScript 语法错误"
                            node -c "$code_file"
                        fi
                    else
                        echo "错误: 未找到 Node.js"
                    fi
                    ;;
                "json")
                    echo "检查 JSON 格式..."
                    if command -v python3 >/dev/null 2>&1; then
                        if python3 -m json.tool "$code_file" >/dev/null 2>&1; then
                            echo "JSON 格式正确"
                        else
                            echo "JSON 格式错误"
                            python3 -m json.tool "$code_file"
                        fi
                    elif command -v jq >/dev/null 2>&1; then
                        if jq . "$code_file" >/dev/null 2>&1; then
                            echo "JSON 格式正确"
                        else
                            echo "JSON 格式错误"
                            jq . "$code_file"
                        fi
                    else
                        echo "提示: 安装 jq 或 python3 可以获得 JSON 格式检查"
                    fi
                    ;;
                "xml")
                    echo "检查 XML 格式..."
                    if command -v xmllint >/dev/null 2>&1; then
                        if xmllint --noout "$code_file" 2>/dev/null; then
                            echo "XML 格式正确"
                        else
                            echo "XML 格式错误"
                            xmllint --noout "$code_file"
                        fi
                    else
                        echo "提示: 安装 xmllint 可以获得 XML 格式检查"
                        echo "      sudo apt install libxml2-utils"
                    fi
                    ;;
                "html"|"htm")
                    echo "检查 HTML 格式..."
                    if command -v tidy >/dev/null 2>&1; then
                        echo "HTML 检查结果:"
                        tidy -q -errors "$code_file" 2>/dev/null
                        local tidy_result=$?
                        if [ $tidy_result -eq 0 ]; then
                            echo "HTML 格式基本正确"
                        elif [ $tidy_result -eq 1 ]; then
                            echo "HTML 存在警告"
                        else
                            echo "HTML 存在错误"
                        fi
                    else
                        echo "提示: 安装 tidy 可以获得 HTML 格式检查"
                        echo "      sudo apt install tidy"
                    fi
                    ;;
                "css")
                    echo "检查 CSS 格式..."
                    if command -v csslint >/dev/null 2>&1; then
                        csslint "$code_file" --quiet 2>/dev/null
                        local csslint_result=$?
                        if [ $csslint_result -eq 0 ]; then
                            echo "CSS 格式正确"
                        else
                            echo "CSS 存在格式问题"
                        fi
                    else
                        echo "提示: 安装 csslint 可以获得 CSS 格式检查"
                        echo "sudo npm install -g csslint"
                    fi
                    ;;
                *)
                    echo "不支持检查 '$extension' 格式的文件"
                    echo "支持的文件类型: sh, py, js, json, xml, html, css"
                    ;;
            esac
            ;;
        "")
            echo -n "请输入文件路径: "
            read -r file_path
            if [ -z "$file_path" ]; then
                echo "错误: 未指定文件路径"
                return 1
            fi
            if [ ! -f "$file_path" ]; then
                echo "错误: 文件 '$file_path' 不存在"
                return 1
            fi
            if [ ! -r "$file_path" ]; then
                echo "错误: 没有读取 '$file_path' 的权限"
                return 1
            fi
            echo "正在检查: $file_path"
            local file_info=$(file -b "$file_path" 2>/dev/null)
            if [ $? -eq 0 ]; then
                echo "文件类型: $file_info"
            else
                echo "文件类型: 未知"
            fi
            local file_size=$(stat -c%s "$file_path" 2>/dev/null || echo "未知")
            echo "文件大小: $file_size 字节"
            echo ""
            echo "编码分析:"
            local first_bytes=$(head -c 3 "$file_path" | od -An -tx1 | tr -d ' \n')
            if [ "$first_bytes" = "efbbbf" ]; then
                echo "UTF-8 with BOM"
            else
                echo "无BOM头"
            fi
            if grep -q -P "[^\x00-\x7F]" "$file_path" 2>/dev/null; then
                echo "包含非法ASCII字符"
                if command -v uchardet >/dev/null 2>&1; then
                    local detected_encoding=$(uchardet "$file_path" 2>/dev/null)
                    echo "检测编码: $detected_encoding"
                elif command -v enca >/dev/null 2>&1; then
                    local detected_encoding=$(enca -L none "$file_path" 2>/dev/null | head -1)
                    echo "检测编码: $detected_encoding"
                else
                    echo "提示: 安装 uchardet 或 enca 可以获得更准确的编码检测"
                fi
            else
                echo "纯ASCII文本"
            fi
            echo "行尾符检查:"
            local crlf_count=$(grep -c -U $'\x0D' "$file_path" 2>/dev/null || echo "0")
            local lf_count=$(grep -c -U $'\x0A' "$file_path" 2>/dev/null || echo "0")
            
            if [ "$crlf_count" -gt 0 ] && [ "$lf_count" -gt 0 ]; then
                echo "混合行尾符 (CRLF+LF)"
            elif [ "$crlf_count" -gt 0 ]; then
                echo "Windows 行尾符 (CRLF)"
            elif [ "$lf_count" -gt 0 ]; then
                echo "Unix 行尾符 (LF)"
            else
                echo "无行尾符或空文件"
            fi
            local blank_lines=$(grep -c '^$' "$file_path" 2>/dev/null || echo "0")
            echo "空行数量: $blank_lines"
            local last_char=$(tail -c 1 "$file_path" | od -An -tx1 | tr -d ' \n')
            if [ "$last_char" = "0a" ]; then
                echo "以换行符结束"
            else
                echo "未以换行符结束"
            fi
            echo ""
            echo "文件预览 (前10行):"
            echo "----------------------------------------"
            head -10 "$file_path" 2>/dev/null | cat -A
            echo "----------------------------------------"
            ;;
        *)
            echo "check 命令用法:"
            echo "  check         - 检查文件编码格式"
            echo "  check -f      - 检查代码文件格式"
            echo ""
            echo "示例:"
            echo "  check         # 检查文件编码"
            echo "  check -f      # 检查代码格式"
            ;;
    esac
    return 0
}
command_UCST() { #简介信息
    echo "Ubuntu Command Simplification Tool——————Ubuntu命令简化工具"
    echo "此工具的开发皆在于简化Ubuntu命令使用户在更便捷的环境下完成工作"
    echo "开源存储库：https://github.com/HXLG-F/Ubuntu-Command-Simplification-Tool"
    echo "输入helpUCST获得可用命令帮助"
    echo "祝您工作顺利！"
}
command_helpUCST() { #现在能用的命令（没写完呢写不动了）
    echo "=== 可用命令 ==="
    echo "UCST        -简介信息"
    echo "about       -查看基本信息"
    echo "about -a    -查看详细信息"
    echo "about -c    -查看处理器信息"
    echo "about -g    -查看显卡信息"
    echo "about -o    -查看操作系统信息"
    echo "about -s    -查看用户信息"
    echo "list        -查看文件列表（可能无效，建议使用ls）"
    echo "delete      -删除文件或目录"
    echo "network -i  -查看网络信息"
    echo "network -c  -查看网卡信息"
    echo "disk        -查看磁盘信息"
    echo "disk -m     -挂载文件系统"
    echo "ctime       -查看时间信息"
    echo "process     -查看进程"
    echo "helpUCST    -查看帮助信息"
    echo "nkill       -强制杀死进程"
    echo "nkill -p    -暂停正在工作的进程"
    echo "nkill -c    -继续被暂停的进程"
    echo "open        -打开文件"
    echo "new         -新建目录或文件"
    echo "mod         -修改文件或目录属性"
    echo "driver      -列出驱动信息"
    echo "driver -r   -查看完全驱动信息"
    echo "driver -i   -安装缺失驱动"
    echo "driver -d   -删除驱动"
    echo "backup      -文件备份与恢复"
    echo "check       -文件编码检查"
}
case "$CMD" in #解释器
    "about")
        command_about
        ;;
    "list")
        command_list
        ;;
    "network")
        command_network
        ;;
    "disk")
        command_disk
        ;;
    "ctime")
        command_ctime
        ;;
    "process")
        command_process
        ;;
    "nkill")
        command_nkill
        ;;
    "open")
        command_open
        ;;
    "delete")
        command_delete
        ;;
    "helpUCST") 
        command_helpUCST
        ;;
    "new")
        command_new
        ;;
    "mod")
        command_mod
        ;;
    "driver")
        command_driver
        ;;
    "backup")
        command_backup
        ;;
    "check")
        command_check
        ;;
    "UCST")
        command_UCST
        ;;
    "")
        echo "Ubuntu Command Simplification Tool——————Ubuntu命令简化工具"
        echo "输入 'helpUCST' 查看可用命令" #就特么六个词记不住诗人握持
        ;;
    *)
        if [ "$CALLED_NAME" = "UCST-English" ]; then #哪个傻逼瞎他妈打命令
            echo "错误: 未知命令 '$CMD'"
            echo "输入 'helpUCST' 查看可用命令" #这么点玩意记不住你也是个人了，赶紧滚去用你那sb的Windows吧
        else
            echo "错误: 未知命令 '$CALLED_NAME'"
            echo "输入 'helpUCST' 查看可用命令" #再他妈瞎打命令半夜给你沙了
        fi
        exit 1
        ;;
esac #寄了






















































##         ##   ####         ####   ####                  ########
##         ##   ####         ####   ####                 ##########
##         ##    ####       ####    ####                ##
##         ##      ####    ####     ####               ##
#############        ########       ####              ##
#############        ########       ####              ##      ######   
##         ##      ####    ####     ####               ##          #
##         ##    ####        ####   ####                ##         #
##         ##  ####           ####  ################     ##########
##         ##  ####           ####  ################      ########
#哈西力工骨灰盒级防伪标识
#瞎搬运司马
#www.520254.com (小惊喜网站，送给搬运司马狗)
